esphome:
  name: glowica-v1_2
  name_add_mac_suffix: true  
  # platform: ESP8266
  # board: nodemcu
  includes:
    - uart_read_line_sensor5.h
  on_boot:
    priority: 1800
    then:
      # - switch.turn_on: loop1
      - script.execute: wysylanie    

  project:
    name: "CyberIN.pl"
    version: "7.0.0"        
      
esp8266:
  board: nodemcuv2
  restore_from_flash: True

# Enable logging
logger:
  level: VERBOSE #makes uart stream available in esphome logstream
  baud_rate: 0 #disable logging over uart


# web_server:
#   port: 80

# Enable Home Assistant API
api:
  # reboot_timeout: 0s

ota:

wifi:
  # ssid: !secret wifi_ssid
  # password: !secret wifi_password

  # Enable fallback hotspot (captive portal) in case wifi connection fails
  ap:
    ssid: "Glowica_Do_Licznika"
  # use_address: "gowica.local"

captive_portal:  

uart:
  - id: uart_2
    tx_pin:
      number: D4
      # inverted: true
      # mode:
      #   output: true
     
  # rx_pin: 3
    baud_rate: 300
    data_bits: 7
    parity: EVEN
    stop_bits: 1
  

  - id: uart_bus
    tx_pin: 15
    #d8
    rx_pin: 13 
    #d7
    # tutaj prędkość taka jaką obsługuje licznik i jaka jestr w skrypcie standardowo 300
    baud_rate: 300
    data_bits: 7
    parity: EVEN
    stop_bits: 1

text_sensor:
- platform: template
  name: Status
  id: status
  update_interval: 300s   


sensor:

  - platform: custom
    lambda: |-
      auto mcs = new UartReadLineSensor(id(uart_bus));
      App.register_component(mcs);
      return {mcs->wskazanie_sensor, mcs->moc_sensor, mcs->oddane_sensor, mcs->l1_sensor, mcs->l2_sensor, mcs->l3_sensor, mcs->moc_zw_sensor, mcs->l1m_sensor, mcs->l2m_sensor, mcs->l3m_sensor, mcs->nm_sensor};
      

    sensors:
    - name: "Moc pobrana suma"
      unit_of_measurement: "kWh"
      accuracy_decimals: 3
      device_class: energy 
      state_class: total_increasing
      icon: "mdi:pulse"        
      # filters:
      #   - multiply: 0.01
      on_value: 
        then:
          - lambda: |-
              id(status).publish_state("OK.");
    - name: "Moc chwilowa pobrana"
      unit_of_measurement: "kW"
      accuracy_decimals: 3
      device_class: current
      # filters:
      #   - multiply: 0.1
    - name: "Moc oddana suma"
      unit_of_measurement: "kWh"
      accuracy_decimals: 2
      device_class: energy 
      state_class: total_increasing
      icon: "mdi:pulse"        
      # filters:
      #   - multiply: 0.1      
    - name: "L1 Napięcie" 
      unit_of_measurement: "V"
      accuracy_decimals: 2
      device_class: voltage
      icon: "mdi:flash-triangle"        
      # filters:
      #   - multiply: 0.1
    - name: "L2 Napięcie" 
      unit_of_measurement: "V"
      accuracy_decimals: 2
      device_class: voltage
      icon: "mdi:flash-triangle"        
      # filters:
      #   - multiply: 0.1  
    - name: "L3 Napięcie" 
      unit_of_measurement: "V"
      accuracy_decimals: 2
      device_class: voltage
      icon: "mdi:flash-triangle"        
      # filters:
      #   - multiply: 0.1    
    - name: "Moc chwilowa oddana"
      unit_of_measurement: "kW"
      accuracy_decimals: 3
      device_class: current
      # filters:
      #   - multiply: 0.001     

    - name: "L1 Natężenie" 
      unit_of_measurement: "A"
      accuracy_decimals: 2
      device_class: current
      icon: "mdi:flash-triangle"        

    - name: "L2 Natężenie" 
      unit_of_measurement: "A"
      accuracy_decimals: 2
      device_class: current
      icon: "mdi:flash-triangle"        

    - name: "L3 Natężenie" 
      unit_of_measurement: "A"
      accuracy_decimals: 2
      device_class: current
      icon: "mdi:flash-triangle"   

    - name: "N Natężenie" 
      unit_of_measurement: "A"
      accuracy_decimals: 2
      device_class: current
      icon: "mdi:flash-triangle"             
                                                   

  - platform: adc
    pin: VCC
    name: "VCC Voltage" 
    update_interval: 300s     
      
script:
  - id: wysylanie
    mode: single
    then:
    - while:
        condition:
            lambda: |-
              return id(loop1).state;    
        then:
        - lambda: |-
            id(status).publish_state("POŁACZENIE");    
        - uart.write:
            id: uart_2 
            data: [0x2F, 0x3F, 0x21, 0x0D, 0x0A]
        - delay: 1500ms
# wyższa niż standardowa        
        # - uart.write: 
        #     id: uart_2
        #     data: [0x06, 0x30, 0x35, 0x30, 0x0D, 0x0A]
# prędkość standardowa
        - uart.write: 
            id: uart_2
            data: [0x06, 0x30, 0x30, 0x30, 0x0D, 0x0A] 
                                 
        - delay: 300s                              
        

switch:          
  - platform: template
    name: "Odczyt cykliczny"
    id: loop1
    optimistic: true
    restore_state: true
    restore_mode: RESTORE_DEFAULT_ON

    on_turn_on:
        - script.execute: wysylanie
    on_turn_off:
        - script.stop: wysylanie    
